// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "content_manifest.pb.h"

@implementation ContentManifestRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [ContentManifestRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface ContentManifestPayload ()
@property (retain) PBAppendableArray * mappingsArray;
@end

@implementation ContentManifestPayload

@synthesize mappingsArray;
@dynamic mappings;
- (void) dealloc {
  self.mappingsArray = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static ContentManifestPayload* defaultContentManifestPayloadInstance = nil;
+ (void) initialize {
  if (self == [ContentManifestPayload class]) {
    defaultContentManifestPayloadInstance = [[ContentManifestPayload alloc] init];
  }
}
+ (ContentManifestPayload*) defaultInstance {
  return defaultContentManifestPayloadInstance;
}
- (ContentManifestPayload*) defaultInstance {
  return defaultContentManifestPayloadInstance;
}
- (PBArray *)mappings {
  return mappingsArray;
}
- (ContentManifestPayload_FileMapping*)mappingsAtIndex:(NSUInteger)index {
  return [mappingsArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (ContentManifestPayload_FileMapping *element in self.mappingsArray) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  for (ContentManifestPayload_FileMapping *element in self.mappingsArray) {
    size_ += computeMessageSize(1, element);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (ContentManifestPayload*) parseFromData:(NSData*) data {
  return (ContentManifestPayload*)[[[ContentManifestPayload builder] mergeFromData:data] build];
}
+ (ContentManifestPayload*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload*)[[[ContentManifestPayload builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload*) parseFromInputStream:(NSInputStream*) input {
  return (ContentManifestPayload*)[[[ContentManifestPayload builder] mergeFromInputStream:input] build];
}
+ (ContentManifestPayload*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload*)[[[ContentManifestPayload builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ContentManifestPayload*)[[[ContentManifestPayload builder] mergeFromCodedInputStream:input] build];
}
+ (ContentManifestPayload*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload*)[[[ContentManifestPayload builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_Builder*) builder {
  return [[[ContentManifestPayload_Builder alloc] init] autorelease];
}
+ (ContentManifestPayload_Builder*) builderWithPrototype:(ContentManifestPayload*) prototype {
  return [[ContentManifestPayload builder] mergeFrom:prototype];
}
- (ContentManifestPayload_Builder*) builder {
  return [ContentManifestPayload builder];
}
- (ContentManifestPayload_Builder*) toBuilder {
  return [ContentManifestPayload builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  for (ContentManifestPayload_FileMapping* element in self.mappingsArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"mappings"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[ContentManifestPayload class]]) {
    return NO;
  }
  ContentManifestPayload *otherMessage = other;
  return
      [self.mappingsArray isEqualToArray:otherMessage.mappingsArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  for (ContentManifestPayload_FileMapping* element in self.mappingsArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface ContentManifestPayload_FileMapping ()
@property (retain) NSString* filename;
@property uint64_t size;
@property uint32_t flags;
@property (retain) NSData* shaFilename;
@property (retain) NSData* shaContent;
@property (retain) PBAppendableArray * chunksArray;
@end

@implementation ContentManifestPayload_FileMapping

- (BOOL) hasFilename {
  return !!hasFilename_;
}
- (void) setHasFilename:(BOOL) value_ {
  hasFilename_ = !!value_;
}
@synthesize filename;
- (BOOL) hasSize {
  return !!hasSize_;
}
- (void) setHasSize:(BOOL) value_ {
  hasSize_ = !!value_;
}
@synthesize size;
- (BOOL) hasFlags {
  return !!hasFlags_;
}
- (void) setHasFlags:(BOOL) value_ {
  hasFlags_ = !!value_;
}
@synthesize flags;
- (BOOL) hasShaFilename {
  return !!hasShaFilename_;
}
- (void) setHasShaFilename:(BOOL) value_ {
  hasShaFilename_ = !!value_;
}
@synthesize shaFilename;
- (BOOL) hasShaContent {
  return !!hasShaContent_;
}
- (void) setHasShaContent:(BOOL) value_ {
  hasShaContent_ = !!value_;
}
@synthesize shaContent;
@synthesize chunksArray;
@dynamic chunks;
- (void) dealloc {
  self.filename = nil;
  self.shaFilename = nil;
  self.shaContent = nil;
  self.chunksArray = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.filename = @"";
    self.size = 0L;
    self.flags = 0;
    self.shaFilename = [NSData data];
    self.shaContent = [NSData data];
  }
  return self;
}
static ContentManifestPayload_FileMapping* defaultContentManifestPayload_FileMappingInstance = nil;
+ (void) initialize {
  if (self == [ContentManifestPayload_FileMapping class]) {
    defaultContentManifestPayload_FileMappingInstance = [[ContentManifestPayload_FileMapping alloc] init];
  }
}
+ (ContentManifestPayload_FileMapping*) defaultInstance {
  return defaultContentManifestPayload_FileMappingInstance;
}
- (ContentManifestPayload_FileMapping*) defaultInstance {
  return defaultContentManifestPayload_FileMappingInstance;
}
- (PBArray *)chunks {
  return chunksArray;
}
- (ContentManifestPayload_FileMapping_ChunkData*)chunksAtIndex:(NSUInteger)index {
  return [chunksArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFilename) {
    [output writeString:1 value:self.filename];
  }
  if (self.hasSize) {
    [output writeUInt64:2 value:self.size];
  }
  if (self.hasFlags) {
    [output writeUInt32:3 value:self.flags];
  }
  if (self.hasShaFilename) {
    [output writeData:4 value:self.shaFilename];
  }
  if (self.hasShaContent) {
    [output writeData:5 value:self.shaContent];
  }
  for (ContentManifestPayload_FileMapping_ChunkData *element in self.chunksArray) {
    [output writeMessage:6 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasFilename) {
    size_ += computeStringSize(1, self.filename);
  }
  if (self.hasSize) {
    size_ += computeUInt64Size(2, self.size);
  }
  if (self.hasFlags) {
    size_ += computeUInt32Size(3, self.flags);
  }
  if (self.hasShaFilename) {
    size_ += computeDataSize(4, self.shaFilename);
  }
  if (self.hasShaContent) {
    size_ += computeDataSize(5, self.shaContent);
  }
  for (ContentManifestPayload_FileMapping_ChunkData *element in self.chunksArray) {
    size_ += computeMessageSize(6, element);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (ContentManifestPayload_FileMapping*) parseFromData:(NSData*) data {
  return (ContentManifestPayload_FileMapping*)[[[ContentManifestPayload_FileMapping builder] mergeFromData:data] build];
}
+ (ContentManifestPayload_FileMapping*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload_FileMapping*)[[[ContentManifestPayload_FileMapping builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_FileMapping*) parseFromInputStream:(NSInputStream*) input {
  return (ContentManifestPayload_FileMapping*)[[[ContentManifestPayload_FileMapping builder] mergeFromInputStream:input] build];
}
+ (ContentManifestPayload_FileMapping*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload_FileMapping*)[[[ContentManifestPayload_FileMapping builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_FileMapping*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ContentManifestPayload_FileMapping*)[[[ContentManifestPayload_FileMapping builder] mergeFromCodedInputStream:input] build];
}
+ (ContentManifestPayload_FileMapping*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload_FileMapping*)[[[ContentManifestPayload_FileMapping builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_FileMapping_Builder*) builder {
  return [[[ContentManifestPayload_FileMapping_Builder alloc] init] autorelease];
}
+ (ContentManifestPayload_FileMapping_Builder*) builderWithPrototype:(ContentManifestPayload_FileMapping*) prototype {
  return [[ContentManifestPayload_FileMapping builder] mergeFrom:prototype];
}
- (ContentManifestPayload_FileMapping_Builder*) builder {
  return [ContentManifestPayload_FileMapping builder];
}
- (ContentManifestPayload_FileMapping_Builder*) toBuilder {
  return [ContentManifestPayload_FileMapping builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasFilename) {
    [output appendFormat:@"%@%@: %@\n", indent, @"filename", self.filename];
  }
  if (self.hasSize) {
    [output appendFormat:@"%@%@: %@\n", indent, @"size", [NSNumber numberWithLongLong:self.size]];
  }
  if (self.hasFlags) {
    [output appendFormat:@"%@%@: %@\n", indent, @"flags", [NSNumber numberWithInt:self.flags]];
  }
  if (self.hasShaFilename) {
    [output appendFormat:@"%@%@: %@\n", indent, @"shaFilename", self.shaFilename];
  }
  if (self.hasShaContent) {
    [output appendFormat:@"%@%@: %@\n", indent, @"shaContent", self.shaContent];
  }
  for (ContentManifestPayload_FileMapping_ChunkData* element in self.chunksArray) {
    [output appendFormat:@"%@%@ {\n", indent, @"chunks"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[ContentManifestPayload_FileMapping class]]) {
    return NO;
  }
  ContentManifestPayload_FileMapping *otherMessage = other;
  return
      self.hasFilename == otherMessage.hasFilename &&
      (!self.hasFilename || [self.filename isEqual:otherMessage.filename]) &&
      self.hasSize == otherMessage.hasSize &&
      (!self.hasSize || self.size == otherMessage.size) &&
      self.hasFlags == otherMessage.hasFlags &&
      (!self.hasFlags || self.flags == otherMessage.flags) &&
      self.hasShaFilename == otherMessage.hasShaFilename &&
      (!self.hasShaFilename || [self.shaFilename isEqual:otherMessage.shaFilename]) &&
      self.hasShaContent == otherMessage.hasShaContent &&
      (!self.hasShaContent || [self.shaContent isEqual:otherMessage.shaContent]) &&
      [self.chunksArray isEqualToArray:otherMessage.chunksArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasFilename) {
    hashCode = hashCode * 31 + [self.filename hash];
  }
  if (self.hasSize) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.size] hash];
  }
  if (self.hasFlags) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.flags] hash];
  }
  if (self.hasShaFilename) {
    hashCode = hashCode * 31 + [self.shaFilename hash];
  }
  if (self.hasShaContent) {
    hashCode = hashCode * 31 + [self.shaContent hash];
  }
  for (ContentManifestPayload_FileMapping_ChunkData* element in self.chunksArray) {
    hashCode = hashCode * 31 + [element hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface ContentManifestPayload_FileMapping_ChunkData ()
@property (retain) NSData* sha;
@property uint32_t crc;
@property uint64_t offset;
@property uint32_t cbOriginal;
@property uint32_t cbCompressed;
@end

@implementation ContentManifestPayload_FileMapping_ChunkData

- (BOOL) hasSha {
  return !!hasSha_;
}
- (void) setHasSha:(BOOL) value_ {
  hasSha_ = !!value_;
}
@synthesize sha;
- (BOOL) hasCrc {
  return !!hasCrc_;
}
- (void) setHasCrc:(BOOL) value_ {
  hasCrc_ = !!value_;
}
@synthesize crc;
- (BOOL) hasOffset {
  return !!hasOffset_;
}
- (void) setHasOffset:(BOOL) value_ {
  hasOffset_ = !!value_;
}
@synthesize offset;
- (BOOL) hasCbOriginal {
  return !!hasCbOriginal_;
}
- (void) setHasCbOriginal:(BOOL) value_ {
  hasCbOriginal_ = !!value_;
}
@synthesize cbOriginal;
- (BOOL) hasCbCompressed {
  return !!hasCbCompressed_;
}
- (void) setHasCbCompressed:(BOOL) value_ {
  hasCbCompressed_ = !!value_;
}
@synthesize cbCompressed;
- (void) dealloc {
  self.sha = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.sha = [NSData data];
    self.crc = 0;
    self.offset = 0L;
    self.cbOriginal = 0;
    self.cbCompressed = 0;
  }
  return self;
}
static ContentManifestPayload_FileMapping_ChunkData* defaultContentManifestPayload_FileMapping_ChunkDataInstance = nil;
+ (void) initialize {
  if (self == [ContentManifestPayload_FileMapping_ChunkData class]) {
    defaultContentManifestPayload_FileMapping_ChunkDataInstance = [[ContentManifestPayload_FileMapping_ChunkData alloc] init];
  }
}
+ (ContentManifestPayload_FileMapping_ChunkData*) defaultInstance {
  return defaultContentManifestPayload_FileMapping_ChunkDataInstance;
}
- (ContentManifestPayload_FileMapping_ChunkData*) defaultInstance {
  return defaultContentManifestPayload_FileMapping_ChunkDataInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSha) {
    [output writeData:1 value:self.sha];
  }
  if (self.hasCrc) {
    [output writeFixed32:2 value:self.crc];
  }
  if (self.hasOffset) {
    [output writeUInt64:3 value:self.offset];
  }
  if (self.hasCbOriginal) {
    [output writeUInt32:4 value:self.cbOriginal];
  }
  if (self.hasCbCompressed) {
    [output writeUInt32:5 value:self.cbCompressed];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasSha) {
    size_ += computeDataSize(1, self.sha);
  }
  if (self.hasCrc) {
    size_ += computeFixed32Size(2, self.crc);
  }
  if (self.hasOffset) {
    size_ += computeUInt64Size(3, self.offset);
  }
  if (self.hasCbOriginal) {
    size_ += computeUInt32Size(4, self.cbOriginal);
  }
  if (self.hasCbCompressed) {
    size_ += computeUInt32Size(5, self.cbCompressed);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (ContentManifestPayload_FileMapping_ChunkData*) parseFromData:(NSData*) data {
  return (ContentManifestPayload_FileMapping_ChunkData*)[[[ContentManifestPayload_FileMapping_ChunkData builder] mergeFromData:data] build];
}
+ (ContentManifestPayload_FileMapping_ChunkData*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload_FileMapping_ChunkData*)[[[ContentManifestPayload_FileMapping_ChunkData builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_FileMapping_ChunkData*) parseFromInputStream:(NSInputStream*) input {
  return (ContentManifestPayload_FileMapping_ChunkData*)[[[ContentManifestPayload_FileMapping_ChunkData builder] mergeFromInputStream:input] build];
}
+ (ContentManifestPayload_FileMapping_ChunkData*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload_FileMapping_ChunkData*)[[[ContentManifestPayload_FileMapping_ChunkData builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_FileMapping_ChunkData*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ContentManifestPayload_FileMapping_ChunkData*)[[[ContentManifestPayload_FileMapping_ChunkData builder] mergeFromCodedInputStream:input] build];
}
+ (ContentManifestPayload_FileMapping_ChunkData*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestPayload_FileMapping_ChunkData*)[[[ContentManifestPayload_FileMapping_ChunkData builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestPayload_FileMapping_ChunkData_Builder*) builder {
  return [[[ContentManifestPayload_FileMapping_ChunkData_Builder alloc] init] autorelease];
}
+ (ContentManifestPayload_FileMapping_ChunkData_Builder*) builderWithPrototype:(ContentManifestPayload_FileMapping_ChunkData*) prototype {
  return [[ContentManifestPayload_FileMapping_ChunkData builder] mergeFrom:prototype];
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) builder {
  return [ContentManifestPayload_FileMapping_ChunkData builder];
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) toBuilder {
  return [ContentManifestPayload_FileMapping_ChunkData builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasSha) {
    [output appendFormat:@"%@%@: %@\n", indent, @"sha", self.sha];
  }
  if (self.hasCrc) {
    [output appendFormat:@"%@%@: %@\n", indent, @"crc", [NSNumber numberWithInt:self.crc]];
  }
  if (self.hasOffset) {
    [output appendFormat:@"%@%@: %@\n", indent, @"offset", [NSNumber numberWithLongLong:self.offset]];
  }
  if (self.hasCbOriginal) {
    [output appendFormat:@"%@%@: %@\n", indent, @"cbOriginal", [NSNumber numberWithInt:self.cbOriginal]];
  }
  if (self.hasCbCompressed) {
    [output appendFormat:@"%@%@: %@\n", indent, @"cbCompressed", [NSNumber numberWithInt:self.cbCompressed]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[ContentManifestPayload_FileMapping_ChunkData class]]) {
    return NO;
  }
  ContentManifestPayload_FileMapping_ChunkData *otherMessage = other;
  return
      self.hasSha == otherMessage.hasSha &&
      (!self.hasSha || [self.sha isEqual:otherMessage.sha]) &&
      self.hasCrc == otherMessage.hasCrc &&
      (!self.hasCrc || self.crc == otherMessage.crc) &&
      self.hasOffset == otherMessage.hasOffset &&
      (!self.hasOffset || self.offset == otherMessage.offset) &&
      self.hasCbOriginal == otherMessage.hasCbOriginal &&
      (!self.hasCbOriginal || self.cbOriginal == otherMessage.cbOriginal) &&
      self.hasCbCompressed == otherMessage.hasCbCompressed &&
      (!self.hasCbCompressed || self.cbCompressed == otherMessage.cbCompressed) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasSha) {
    hashCode = hashCode * 31 + [self.sha hash];
  }
  if (self.hasCrc) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.crc] hash];
  }
  if (self.hasOffset) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.offset] hash];
  }
  if (self.hasCbOriginal) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.cbOriginal] hash];
  }
  if (self.hasCbCompressed) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.cbCompressed] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface ContentManifestPayload_FileMapping_ChunkData_Builder()
@property (retain) ContentManifestPayload_FileMapping_ChunkData* _builderResult;
@end

@implementation ContentManifestPayload_FileMapping_ChunkData_Builder
@synthesize _builderResult;
- (void) dealloc {
  self._builderResult = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self._builderResult = [[[ContentManifestPayload_FileMapping_ChunkData alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return _builderResult;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clear {
  _builderResult = [[[ContentManifestPayload_FileMapping_ChunkData alloc] init] autorelease];
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clone {
  return [ContentManifestPayload_FileMapping_ChunkData builderWithPrototype:_builderResult];
}
- (ContentManifestPayload_FileMapping_ChunkData*) defaultInstance {
  return [ContentManifestPayload_FileMapping_ChunkData defaultInstance];
}
- (ContentManifestPayload_FileMapping_ChunkData*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ContentManifestPayload_FileMapping_ChunkData*) buildPartial {
  ContentManifestPayload_FileMapping_ChunkData* returnMe = [[_builderResult retain] autorelease];
  self._builderResult = nil;
  return returnMe;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) mergeFrom:(ContentManifestPayload_FileMapping_ChunkData*) other {
  if (other == [ContentManifestPayload_FileMapping_ChunkData defaultInstance]) {
    return self;
  }
  if (other.hasSha) {
    [self setSha:other.sha];
  }
  if (other.hasCrc) {
    [self setCrc:other.crc];
  }
  if (other.hasOffset) {
    [self setOffset:other.offset];
  }
  if (other.hasCbOriginal) {
    [self setCbOriginal:other.cbOriginal];
  }
  if (other.hasCbCompressed) {
    [self setCbCompressed:other.cbCompressed];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setSha:[input readData]];
        break;
      }
      case 21: {
        [self setCrc:[input readFixed32]];
        break;
      }
      case 24: {
        [self setOffset:[input readUInt64]];
        break;
      }
      case 32: {
        [self setCbOriginal:[input readUInt32]];
        break;
      }
      case 40: {
        [self setCbCompressed:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasSha {
  return _builderResult.hasSha;
}
- (NSData*) sha {
  return _builderResult.sha;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) setSha:(NSData*) value {
  _builderResult.hasSha = YES;
  _builderResult.sha = value;
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clearSha {
  _builderResult.hasSha = NO;
  _builderResult.sha = [NSData data];
  return self;
}
- (BOOL) hasCrc {
  return _builderResult.hasCrc;
}
- (uint32_t) crc {
  return _builderResult.crc;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) setCrc:(uint32_t) value {
  _builderResult.hasCrc = YES;
  _builderResult.crc = value;
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clearCrc {
  _builderResult.hasCrc = NO;
  _builderResult.crc = 0;
  return self;
}
- (BOOL) hasOffset {
  return _builderResult.hasOffset;
}
- (uint64_t) offset {
  return _builderResult.offset;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) setOffset:(uint64_t) value {
  _builderResult.hasOffset = YES;
  _builderResult.offset = value;
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clearOffset {
  _builderResult.hasOffset = NO;
  _builderResult.offset = 0L;
  return self;
}
- (BOOL) hasCbOriginal {
  return _builderResult.hasCbOriginal;
}
- (uint32_t) cbOriginal {
  return _builderResult.cbOriginal;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) setCbOriginal:(uint32_t) value {
  _builderResult.hasCbOriginal = YES;
  _builderResult.cbOriginal = value;
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clearCbOriginal {
  _builderResult.hasCbOriginal = NO;
  _builderResult.cbOriginal = 0;
  return self;
}
- (BOOL) hasCbCompressed {
  return _builderResult.hasCbCompressed;
}
- (uint32_t) cbCompressed {
  return _builderResult.cbCompressed;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) setCbCompressed:(uint32_t) value {
  _builderResult.hasCbCompressed = YES;
  _builderResult.cbCompressed = value;
  return self;
}
- (ContentManifestPayload_FileMapping_ChunkData_Builder*) clearCbCompressed {
  _builderResult.hasCbCompressed = NO;
  _builderResult.cbCompressed = 0;
  return self;
}
@end

@interface ContentManifestPayload_FileMapping_Builder()
@property (retain) ContentManifestPayload_FileMapping* _builderResult;
@end

@implementation ContentManifestPayload_FileMapping_Builder
@synthesize _builderResult;
- (void) dealloc {
  self._builderResult = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self._builderResult = [[[ContentManifestPayload_FileMapping alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return _builderResult;
}
- (ContentManifestPayload_FileMapping_Builder*) clear {
  _builderResult = [[[ContentManifestPayload_FileMapping alloc] init] autorelease];
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) clone {
  return [ContentManifestPayload_FileMapping builderWithPrototype:_builderResult];
}
- (ContentManifestPayload_FileMapping*) defaultInstance {
  return [ContentManifestPayload_FileMapping defaultInstance];
}
- (ContentManifestPayload_FileMapping*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ContentManifestPayload_FileMapping*) buildPartial {
  ContentManifestPayload_FileMapping* returnMe = [[_builderResult retain] autorelease];
  self._builderResult = nil;
  return returnMe;
}
- (ContentManifestPayload_FileMapping_Builder*) mergeFrom:(ContentManifestPayload_FileMapping*) other {
  if (other == [ContentManifestPayload_FileMapping defaultInstance]) {
    return self;
  }
  if (other.hasFilename) {
    [self setFilename:other.filename];
  }
  if (other.hasSize) {
    [self setSize:other.size];
  }
  if (other.hasFlags) {
    [self setFlags:other.flags];
  }
  if (other.hasShaFilename) {
    [self setShaFilename:other.shaFilename];
  }
  if (other.hasShaContent) {
    [self setShaContent:other.shaContent];
  }
  if (other.chunksArray.count > 0) {
    if (_builderResult.chunksArray == nil) {
      _builderResult.chunksArray = [[other.chunksArray copyWithZone:[other.chunksArray zone]] autorelease];
    } else {
      [_builderResult.chunksArray appendArray:other.chunksArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ContentManifestPayload_FileMapping_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFilename:[input readString]];
        break;
      }
      case 16: {
        [self setSize:[input readUInt64]];
        break;
      }
      case 24: {
        [self setFlags:[input readUInt32]];
        break;
      }
      case 34: {
        [self setShaFilename:[input readData]];
        break;
      }
      case 42: {
        [self setShaContent:[input readData]];
        break;
      }
      case 50: {
        ContentManifestPayload_FileMapping_ChunkData_Builder* subBuilder = [ContentManifestPayload_FileMapping_ChunkData builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunks:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFilename {
  return _builderResult.hasFilename;
}
- (NSString*) filename {
  return _builderResult.filename;
}
- (ContentManifestPayload_FileMapping_Builder*) setFilename:(NSString*) value {
  _builderResult.hasFilename = YES;
  _builderResult.filename = value;
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) clearFilename {
  _builderResult.hasFilename = NO;
  _builderResult.filename = @"";
  return self;
}
- (BOOL) hasSize {
  return _builderResult.hasSize;
}
- (uint64_t) size {
  return _builderResult.size;
}
- (ContentManifestPayload_FileMapping_Builder*) setSize:(uint64_t) value {
  _builderResult.hasSize = YES;
  _builderResult.size = value;
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) clearSize {
  _builderResult.hasSize = NO;
  _builderResult.size = 0L;
  return self;
}
- (BOOL) hasFlags {
  return _builderResult.hasFlags;
}
- (uint32_t) flags {
  return _builderResult.flags;
}
- (ContentManifestPayload_FileMapping_Builder*) setFlags:(uint32_t) value {
  _builderResult.hasFlags = YES;
  _builderResult.flags = value;
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) clearFlags {
  _builderResult.hasFlags = NO;
  _builderResult.flags = 0;
  return self;
}
- (BOOL) hasShaFilename {
  return _builderResult.hasShaFilename;
}
- (NSData*) shaFilename {
  return _builderResult.shaFilename;
}
- (ContentManifestPayload_FileMapping_Builder*) setShaFilename:(NSData*) value {
  _builderResult.hasShaFilename = YES;
  _builderResult.shaFilename = value;
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) clearShaFilename {
  _builderResult.hasShaFilename = NO;
  _builderResult.shaFilename = [NSData data];
  return self;
}
- (BOOL) hasShaContent {
  return _builderResult.hasShaContent;
}
- (NSData*) shaContent {
  return _builderResult.shaContent;
}
- (ContentManifestPayload_FileMapping_Builder*) setShaContent:(NSData*) value {
  _builderResult.hasShaContent = YES;
  _builderResult.shaContent = value;
  return self;
}
- (ContentManifestPayload_FileMapping_Builder*) clearShaContent {
  _builderResult.hasShaContent = NO;
  _builderResult.shaContent = [NSData data];
  return self;
}
- (PBAppendableArray *)chunks {
  return _builderResult.chunksArray;
}
- (ContentManifestPayload_FileMapping_ChunkData*)chunksAtIndex:(NSUInteger)index {
  return [_builderResult chunksAtIndex:index];
}
- (ContentManifestPayload_FileMapping_Builder *)addChunks:(ContentManifestPayload_FileMapping_ChunkData*)value {
  if (_builderResult.chunksArray == nil) {
    _builderResult.chunksArray = [PBAppendableArray arrayWithValueType:PBArrayValueTypeObject];
  }
  [_builderResult.chunksArray addObject:value];
  return self;
}
- (ContentManifestPayload_FileMapping_Builder *)setChunksArray:(NSArray *)array {
  _builderResult.chunksArray = [PBAppendableArray arrayWithArray:array valueType:PBArrayValueTypeObject];
  return self;
}
- (ContentManifestPayload_FileMapping_Builder *)setChunksValues:(const ContentManifestPayload_FileMapping_ChunkData* *)values count:(NSUInteger)count {
  _builderResult.chunksArray = [PBAppendableArray arrayWithValues:values count:count valueType:PBArrayValueTypeObject];
  return self;
}
- (ContentManifestPayload_FileMapping_Builder *)clearChunks {
  _builderResult.chunksArray = nil;
  return self;
}
@end

@interface ContentManifestPayload_Builder()
@property (retain) ContentManifestPayload* _builderResult;
@end

@implementation ContentManifestPayload_Builder
@synthesize _builderResult;
- (void) dealloc {
  self._builderResult = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self._builderResult = [[[ContentManifestPayload alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return _builderResult;
}
- (ContentManifestPayload_Builder*) clear {
  _builderResult = [[[ContentManifestPayload alloc] init] autorelease];
  return self;
}
- (ContentManifestPayload_Builder*) clone {
  return [ContentManifestPayload builderWithPrototype:_builderResult];
}
- (ContentManifestPayload*) defaultInstance {
  return [ContentManifestPayload defaultInstance];
}
- (ContentManifestPayload*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ContentManifestPayload*) buildPartial {
  ContentManifestPayload* returnMe = [[_builderResult retain] autorelease];
  self._builderResult = nil;
  return returnMe;
}
- (ContentManifestPayload_Builder*) mergeFrom:(ContentManifestPayload*) other {
  if (other == [ContentManifestPayload defaultInstance]) {
    return self;
  }
  if (other.mappingsArray.count > 0) {
    if (_builderResult.mappingsArray == nil) {
      _builderResult.mappingsArray = [[other.mappingsArray copyWithZone:[other.mappingsArray zone]] autorelease];
    } else {
      [_builderResult.mappingsArray appendArray:other.mappingsArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ContentManifestPayload_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ContentManifestPayload_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        ContentManifestPayload_FileMapping_Builder* subBuilder = [ContentManifestPayload_FileMapping builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addMappings:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (PBAppendableArray *)mappings {
  return _builderResult.mappingsArray;
}
- (ContentManifestPayload_FileMapping*)mappingsAtIndex:(NSUInteger)index {
  return [_builderResult mappingsAtIndex:index];
}
- (ContentManifestPayload_Builder *)addMappings:(ContentManifestPayload_FileMapping*)value {
  if (_builderResult.mappingsArray == nil) {
    _builderResult.mappingsArray = [PBAppendableArray arrayWithValueType:PBArrayValueTypeObject];
  }
  [_builderResult.mappingsArray addObject:value];
  return self;
}
- (ContentManifestPayload_Builder *)setMappingsArray:(NSArray *)array {
  _builderResult.mappingsArray = [PBAppendableArray arrayWithArray:array valueType:PBArrayValueTypeObject];
  return self;
}
- (ContentManifestPayload_Builder *)setMappingsValues:(const ContentManifestPayload_FileMapping* *)values count:(NSUInteger)count {
  _builderResult.mappingsArray = [PBAppendableArray arrayWithValues:values count:count valueType:PBArrayValueTypeObject];
  return self;
}
- (ContentManifestPayload_Builder *)clearMappings {
  _builderResult.mappingsArray = nil;
  return self;
}
@end

@interface ContentManifestMetadata ()
@property uint32_t depotId;
@property uint64_t gidManifest;
@property uint32_t creationTime;
@property BOOL filenamesEncrypted;
@property uint64_t cbDiskOriginal;
@property uint64_t cbDiskCompressed;
@property uint32_t uniqueChunks;
@property uint32_t crcEncrypted;
@property uint32_t crcClear;
@end

@implementation ContentManifestMetadata

- (BOOL) hasDepotId {
  return !!hasDepotId_;
}
- (void) setHasDepotId:(BOOL) value_ {
  hasDepotId_ = !!value_;
}
@synthesize depotId;
- (BOOL) hasGidManifest {
  return !!hasGidManifest_;
}
- (void) setHasGidManifest:(BOOL) value_ {
  hasGidManifest_ = !!value_;
}
@synthesize gidManifest;
- (BOOL) hasCreationTime {
  return !!hasCreationTime_;
}
- (void) setHasCreationTime:(BOOL) value_ {
  hasCreationTime_ = !!value_;
}
@synthesize creationTime;
- (BOOL) hasFilenamesEncrypted {
  return !!hasFilenamesEncrypted_;
}
- (void) setHasFilenamesEncrypted:(BOOL) value_ {
  hasFilenamesEncrypted_ = !!value_;
}
- (BOOL) filenamesEncrypted {
  return !!filenamesEncrypted_;
}
- (void) setFilenamesEncrypted:(BOOL) value_ {
  filenamesEncrypted_ = !!value_;
}
- (BOOL) hasCbDiskOriginal {
  return !!hasCbDiskOriginal_;
}
- (void) setHasCbDiskOriginal:(BOOL) value_ {
  hasCbDiskOriginal_ = !!value_;
}
@synthesize cbDiskOriginal;
- (BOOL) hasCbDiskCompressed {
  return !!hasCbDiskCompressed_;
}
- (void) setHasCbDiskCompressed:(BOOL) value_ {
  hasCbDiskCompressed_ = !!value_;
}
@synthesize cbDiskCompressed;
- (BOOL) hasUniqueChunks {
  return !!hasUniqueChunks_;
}
- (void) setHasUniqueChunks:(BOOL) value_ {
  hasUniqueChunks_ = !!value_;
}
@synthesize uniqueChunks;
- (BOOL) hasCrcEncrypted {
  return !!hasCrcEncrypted_;
}
- (void) setHasCrcEncrypted:(BOOL) value_ {
  hasCrcEncrypted_ = !!value_;
}
@synthesize crcEncrypted;
- (BOOL) hasCrcClear {
  return !!hasCrcClear_;
}
- (void) setHasCrcClear:(BOOL) value_ {
  hasCrcClear_ = !!value_;
}
@synthesize crcClear;
- (void) dealloc {
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.depotId = 0;
    self.gidManifest = 0L;
    self.creationTime = 0;
    self.filenamesEncrypted = NO;
    self.cbDiskOriginal = 0L;
    self.cbDiskCompressed = 0L;
    self.uniqueChunks = 0;
    self.crcEncrypted = 0;
    self.crcClear = 0;
  }
  return self;
}
static ContentManifestMetadata* defaultContentManifestMetadataInstance = nil;
+ (void) initialize {
  if (self == [ContentManifestMetadata class]) {
    defaultContentManifestMetadataInstance = [[ContentManifestMetadata alloc] init];
  }
}
+ (ContentManifestMetadata*) defaultInstance {
  return defaultContentManifestMetadataInstance;
}
- (ContentManifestMetadata*) defaultInstance {
  return defaultContentManifestMetadataInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasDepotId) {
    [output writeUInt32:1 value:self.depotId];
  }
  if (self.hasGidManifest) {
    [output writeUInt64:2 value:self.gidManifest];
  }
  if (self.hasCreationTime) {
    [output writeUInt32:3 value:self.creationTime];
  }
  if (self.hasFilenamesEncrypted) {
    [output writeBool:4 value:self.filenamesEncrypted];
  }
  if (self.hasCbDiskOriginal) {
    [output writeUInt64:5 value:self.cbDiskOriginal];
  }
  if (self.hasCbDiskCompressed) {
    [output writeUInt64:6 value:self.cbDiskCompressed];
  }
  if (self.hasUniqueChunks) {
    [output writeUInt32:7 value:self.uniqueChunks];
  }
  if (self.hasCrcEncrypted) {
    [output writeUInt32:8 value:self.crcEncrypted];
  }
  if (self.hasCrcClear) {
    [output writeUInt32:9 value:self.crcClear];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasDepotId) {
    size_ += computeUInt32Size(1, self.depotId);
  }
  if (self.hasGidManifest) {
    size_ += computeUInt64Size(2, self.gidManifest);
  }
  if (self.hasCreationTime) {
    size_ += computeUInt32Size(3, self.creationTime);
  }
  if (self.hasFilenamesEncrypted) {
    size_ += computeBoolSize(4, self.filenamesEncrypted);
  }
  if (self.hasCbDiskOriginal) {
    size_ += computeUInt64Size(5, self.cbDiskOriginal);
  }
  if (self.hasCbDiskCompressed) {
    size_ += computeUInt64Size(6, self.cbDiskCompressed);
  }
  if (self.hasUniqueChunks) {
    size_ += computeUInt32Size(7, self.uniqueChunks);
  }
  if (self.hasCrcEncrypted) {
    size_ += computeUInt32Size(8, self.crcEncrypted);
  }
  if (self.hasCrcClear) {
    size_ += computeUInt32Size(9, self.crcClear);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (ContentManifestMetadata*) parseFromData:(NSData*) data {
  return (ContentManifestMetadata*)[[[ContentManifestMetadata builder] mergeFromData:data] build];
}
+ (ContentManifestMetadata*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestMetadata*)[[[ContentManifestMetadata builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestMetadata*) parseFromInputStream:(NSInputStream*) input {
  return (ContentManifestMetadata*)[[[ContentManifestMetadata builder] mergeFromInputStream:input] build];
}
+ (ContentManifestMetadata*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestMetadata*)[[[ContentManifestMetadata builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestMetadata*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ContentManifestMetadata*)[[[ContentManifestMetadata builder] mergeFromCodedInputStream:input] build];
}
+ (ContentManifestMetadata*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestMetadata*)[[[ContentManifestMetadata builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestMetadata_Builder*) builder {
  return [[[ContentManifestMetadata_Builder alloc] init] autorelease];
}
+ (ContentManifestMetadata_Builder*) builderWithPrototype:(ContentManifestMetadata*) prototype {
  return [[ContentManifestMetadata builder] mergeFrom:prototype];
}
- (ContentManifestMetadata_Builder*) builder {
  return [ContentManifestMetadata builder];
}
- (ContentManifestMetadata_Builder*) toBuilder {
  return [ContentManifestMetadata builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasDepotId) {
    [output appendFormat:@"%@%@: %@\n", indent, @"depotId", [NSNumber numberWithInt:self.depotId]];
  }
  if (self.hasGidManifest) {
    [output appendFormat:@"%@%@: %@\n", indent, @"gidManifest", [NSNumber numberWithLongLong:self.gidManifest]];
  }
  if (self.hasCreationTime) {
    [output appendFormat:@"%@%@: %@\n", indent, @"creationTime", [NSNumber numberWithInt:self.creationTime]];
  }
  if (self.hasFilenamesEncrypted) {
    [output appendFormat:@"%@%@: %@\n", indent, @"filenamesEncrypted", [NSNumber numberWithBool:self.filenamesEncrypted]];
  }
  if (self.hasCbDiskOriginal) {
    [output appendFormat:@"%@%@: %@\n", indent, @"cbDiskOriginal", [NSNumber numberWithLongLong:self.cbDiskOriginal]];
  }
  if (self.hasCbDiskCompressed) {
    [output appendFormat:@"%@%@: %@\n", indent, @"cbDiskCompressed", [NSNumber numberWithLongLong:self.cbDiskCompressed]];
  }
  if (self.hasUniqueChunks) {
    [output appendFormat:@"%@%@: %@\n", indent, @"uniqueChunks", [NSNumber numberWithInt:self.uniqueChunks]];
  }
  if (self.hasCrcEncrypted) {
    [output appendFormat:@"%@%@: %@\n", indent, @"crcEncrypted", [NSNumber numberWithInt:self.crcEncrypted]];
  }
  if (self.hasCrcClear) {
    [output appendFormat:@"%@%@: %@\n", indent, @"crcClear", [NSNumber numberWithInt:self.crcClear]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[ContentManifestMetadata class]]) {
    return NO;
  }
  ContentManifestMetadata *otherMessage = other;
  return
      self.hasDepotId == otherMessage.hasDepotId &&
      (!self.hasDepotId || self.depotId == otherMessage.depotId) &&
      self.hasGidManifest == otherMessage.hasGidManifest &&
      (!self.hasGidManifest || self.gidManifest == otherMessage.gidManifest) &&
      self.hasCreationTime == otherMessage.hasCreationTime &&
      (!self.hasCreationTime || self.creationTime == otherMessage.creationTime) &&
      self.hasFilenamesEncrypted == otherMessage.hasFilenamesEncrypted &&
      (!self.hasFilenamesEncrypted || self.filenamesEncrypted == otherMessage.filenamesEncrypted) &&
      self.hasCbDiskOriginal == otherMessage.hasCbDiskOriginal &&
      (!self.hasCbDiskOriginal || self.cbDiskOriginal == otherMessage.cbDiskOriginal) &&
      self.hasCbDiskCompressed == otherMessage.hasCbDiskCompressed &&
      (!self.hasCbDiskCompressed || self.cbDiskCompressed == otherMessage.cbDiskCompressed) &&
      self.hasUniqueChunks == otherMessage.hasUniqueChunks &&
      (!self.hasUniqueChunks || self.uniqueChunks == otherMessage.uniqueChunks) &&
      self.hasCrcEncrypted == otherMessage.hasCrcEncrypted &&
      (!self.hasCrcEncrypted || self.crcEncrypted == otherMessage.crcEncrypted) &&
      self.hasCrcClear == otherMessage.hasCrcClear &&
      (!self.hasCrcClear || self.crcClear == otherMessage.crcClear) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasDepotId) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.depotId] hash];
  }
  if (self.hasGidManifest) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.gidManifest] hash];
  }
  if (self.hasCreationTime) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.creationTime] hash];
  }
  if (self.hasFilenamesEncrypted) {
    hashCode = hashCode * 31 + [[NSNumber numberWithBool:self.filenamesEncrypted] hash];
  }
  if (self.hasCbDiskOriginal) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.cbDiskOriginal] hash];
  }
  if (self.hasCbDiskCompressed) {
    hashCode = hashCode * 31 + [[NSNumber numberWithLongLong:self.cbDiskCompressed] hash];
  }
  if (self.hasUniqueChunks) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.uniqueChunks] hash];
  }
  if (self.hasCrcEncrypted) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.crcEncrypted] hash];
  }
  if (self.hasCrcClear) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInt:self.crcClear] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface ContentManifestMetadata_Builder()
@property (retain) ContentManifestMetadata* _builderResult;
@end

@implementation ContentManifestMetadata_Builder
@synthesize _builderResult;
- (void) dealloc {
  self._builderResult = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self._builderResult = [[[ContentManifestMetadata alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return _builderResult;
}
- (ContentManifestMetadata_Builder*) clear {
  _builderResult = [[[ContentManifestMetadata alloc] init] autorelease];
  return self;
}
- (ContentManifestMetadata_Builder*) clone {
  return [ContentManifestMetadata builderWithPrototype:_builderResult];
}
- (ContentManifestMetadata*) defaultInstance {
  return [ContentManifestMetadata defaultInstance];
}
- (ContentManifestMetadata*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ContentManifestMetadata*) buildPartial {
  ContentManifestMetadata* returnMe = [[_builderResult retain] autorelease];
  self._builderResult = nil;
  return returnMe;
}
- (ContentManifestMetadata_Builder*) mergeFrom:(ContentManifestMetadata*) other {
  if (other == [ContentManifestMetadata defaultInstance]) {
    return self;
  }
  if (other.hasDepotId) {
    [self setDepotId:other.depotId];
  }
  if (other.hasGidManifest) {
    [self setGidManifest:other.gidManifest];
  }
  if (other.hasCreationTime) {
    [self setCreationTime:other.creationTime];
  }
  if (other.hasFilenamesEncrypted) {
    [self setFilenamesEncrypted:other.filenamesEncrypted];
  }
  if (other.hasCbDiskOriginal) {
    [self setCbDiskOriginal:other.cbDiskOriginal];
  }
  if (other.hasCbDiskCompressed) {
    [self setCbDiskCompressed:other.cbDiskCompressed];
  }
  if (other.hasUniqueChunks) {
    [self setUniqueChunks:other.uniqueChunks];
  }
  if (other.hasCrcEncrypted) {
    [self setCrcEncrypted:other.crcEncrypted];
  }
  if (other.hasCrcClear) {
    [self setCrcClear:other.crcClear];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ContentManifestMetadata_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ContentManifestMetadata_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setDepotId:[input readUInt32]];
        break;
      }
      case 16: {
        [self setGidManifest:[input readUInt64]];
        break;
      }
      case 24: {
        [self setCreationTime:[input readUInt32]];
        break;
      }
      case 32: {
        [self setFilenamesEncrypted:[input readBool]];
        break;
      }
      case 40: {
        [self setCbDiskOriginal:[input readUInt64]];
        break;
      }
      case 48: {
        [self setCbDiskCompressed:[input readUInt64]];
        break;
      }
      case 56: {
        [self setUniqueChunks:[input readUInt32]];
        break;
      }
      case 64: {
        [self setCrcEncrypted:[input readUInt32]];
        break;
      }
      case 72: {
        [self setCrcClear:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasDepotId {
  return _builderResult.hasDepotId;
}
- (uint32_t) depotId {
  return _builderResult.depotId;
}
- (ContentManifestMetadata_Builder*) setDepotId:(uint32_t) value {
  _builderResult.hasDepotId = YES;
  _builderResult.depotId = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearDepotId {
  _builderResult.hasDepotId = NO;
  _builderResult.depotId = 0;
  return self;
}
- (BOOL) hasGidManifest {
  return _builderResult.hasGidManifest;
}
- (uint64_t) gidManifest {
  return _builderResult.gidManifest;
}
- (ContentManifestMetadata_Builder*) setGidManifest:(uint64_t) value {
  _builderResult.hasGidManifest = YES;
  _builderResult.gidManifest = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearGidManifest {
  _builderResult.hasGidManifest = NO;
  _builderResult.gidManifest = 0L;
  return self;
}
- (BOOL) hasCreationTime {
  return _builderResult.hasCreationTime;
}
- (uint32_t) creationTime {
  return _builderResult.creationTime;
}
- (ContentManifestMetadata_Builder*) setCreationTime:(uint32_t) value {
  _builderResult.hasCreationTime = YES;
  _builderResult.creationTime = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearCreationTime {
  _builderResult.hasCreationTime = NO;
  _builderResult.creationTime = 0;
  return self;
}
- (BOOL) hasFilenamesEncrypted {
  return _builderResult.hasFilenamesEncrypted;
}
- (BOOL) filenamesEncrypted {
  return _builderResult.filenamesEncrypted;
}
- (ContentManifestMetadata_Builder*) setFilenamesEncrypted:(BOOL) value {
  _builderResult.hasFilenamesEncrypted = YES;
  _builderResult.filenamesEncrypted = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearFilenamesEncrypted {
  _builderResult.hasFilenamesEncrypted = NO;
  _builderResult.filenamesEncrypted = NO;
  return self;
}
- (BOOL) hasCbDiskOriginal {
  return _builderResult.hasCbDiskOriginal;
}
- (uint64_t) cbDiskOriginal {
  return _builderResult.cbDiskOriginal;
}
- (ContentManifestMetadata_Builder*) setCbDiskOriginal:(uint64_t) value {
  _builderResult.hasCbDiskOriginal = YES;
  _builderResult.cbDiskOriginal = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearCbDiskOriginal {
  _builderResult.hasCbDiskOriginal = NO;
  _builderResult.cbDiskOriginal = 0L;
  return self;
}
- (BOOL) hasCbDiskCompressed {
  return _builderResult.hasCbDiskCompressed;
}
- (uint64_t) cbDiskCompressed {
  return _builderResult.cbDiskCompressed;
}
- (ContentManifestMetadata_Builder*) setCbDiskCompressed:(uint64_t) value {
  _builderResult.hasCbDiskCompressed = YES;
  _builderResult.cbDiskCompressed = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearCbDiskCompressed {
  _builderResult.hasCbDiskCompressed = NO;
  _builderResult.cbDiskCompressed = 0L;
  return self;
}
- (BOOL) hasUniqueChunks {
  return _builderResult.hasUniqueChunks;
}
- (uint32_t) uniqueChunks {
  return _builderResult.uniqueChunks;
}
- (ContentManifestMetadata_Builder*) setUniqueChunks:(uint32_t) value {
  _builderResult.hasUniqueChunks = YES;
  _builderResult.uniqueChunks = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearUniqueChunks {
  _builderResult.hasUniqueChunks = NO;
  _builderResult.uniqueChunks = 0;
  return self;
}
- (BOOL) hasCrcEncrypted {
  return _builderResult.hasCrcEncrypted;
}
- (uint32_t) crcEncrypted {
  return _builderResult.crcEncrypted;
}
- (ContentManifestMetadata_Builder*) setCrcEncrypted:(uint32_t) value {
  _builderResult.hasCrcEncrypted = YES;
  _builderResult.crcEncrypted = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearCrcEncrypted {
  _builderResult.hasCrcEncrypted = NO;
  _builderResult.crcEncrypted = 0;
  return self;
}
- (BOOL) hasCrcClear {
  return _builderResult.hasCrcClear;
}
- (uint32_t) crcClear {
  return _builderResult.crcClear;
}
- (ContentManifestMetadata_Builder*) setCrcClear:(uint32_t) value {
  _builderResult.hasCrcClear = YES;
  _builderResult.crcClear = value;
  return self;
}
- (ContentManifestMetadata_Builder*) clearCrcClear {
  _builderResult.hasCrcClear = NO;
  _builderResult.crcClear = 0;
  return self;
}
@end

@interface ContentManifestSignature ()
@property (retain) NSData* signature;
@end

@implementation ContentManifestSignature

- (BOOL) hasSignature {
  return !!hasSignature_;
}
- (void) setHasSignature:(BOOL) value_ {
  hasSignature_ = !!value_;
}
@synthesize signature;
- (void) dealloc {
  self.signature = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.signature = [NSData data];
  }
  return self;
}
static ContentManifestSignature* defaultContentManifestSignatureInstance = nil;
+ (void) initialize {
  if (self == [ContentManifestSignature class]) {
    defaultContentManifestSignatureInstance = [[ContentManifestSignature alloc] init];
  }
}
+ (ContentManifestSignature*) defaultInstance {
  return defaultContentManifestSignatureInstance;
}
- (ContentManifestSignature*) defaultInstance {
  return defaultContentManifestSignatureInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSignature) {
    [output writeData:1 value:self.signature];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasSignature) {
    size_ += computeDataSize(1, self.signature);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (ContentManifestSignature*) parseFromData:(NSData*) data {
  return (ContentManifestSignature*)[[[ContentManifestSignature builder] mergeFromData:data] build];
}
+ (ContentManifestSignature*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestSignature*)[[[ContentManifestSignature builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestSignature*) parseFromInputStream:(NSInputStream*) input {
  return (ContentManifestSignature*)[[[ContentManifestSignature builder] mergeFromInputStream:input] build];
}
+ (ContentManifestSignature*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestSignature*)[[[ContentManifestSignature builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestSignature*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ContentManifestSignature*)[[[ContentManifestSignature builder] mergeFromCodedInputStream:input] build];
}
+ (ContentManifestSignature*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ContentManifestSignature*)[[[ContentManifestSignature builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ContentManifestSignature_Builder*) builder {
  return [[[ContentManifestSignature_Builder alloc] init] autorelease];
}
+ (ContentManifestSignature_Builder*) builderWithPrototype:(ContentManifestSignature*) prototype {
  return [[ContentManifestSignature builder] mergeFrom:prototype];
}
- (ContentManifestSignature_Builder*) builder {
  return [ContentManifestSignature builder];
}
- (ContentManifestSignature_Builder*) toBuilder {
  return [ContentManifestSignature builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasSignature) {
    [output appendFormat:@"%@%@: %@\n", indent, @"signature", self.signature];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[ContentManifestSignature class]]) {
    return NO;
  }
  ContentManifestSignature *otherMessage = other;
  return
      self.hasSignature == otherMessage.hasSignature &&
      (!self.hasSignature || [self.signature isEqual:otherMessage.signature]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  NSUInteger hashCode = 7;
  if (self.hasSignature) {
    hashCode = hashCode * 31 + [self.signature hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface ContentManifestSignature_Builder()
@property (retain) ContentManifestSignature* _builderResult;
@end

@implementation ContentManifestSignature_Builder
@synthesize _builderResult;
- (void) dealloc {
  self._builderResult = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self._builderResult = [[[ContentManifestSignature alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return _builderResult;
}
- (ContentManifestSignature_Builder*) clear {
  _builderResult = [[[ContentManifestSignature alloc] init] autorelease];
  return self;
}
- (ContentManifestSignature_Builder*) clone {
  return [ContentManifestSignature builderWithPrototype:_builderResult];
}
- (ContentManifestSignature*) defaultInstance {
  return [ContentManifestSignature defaultInstance];
}
- (ContentManifestSignature*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ContentManifestSignature*) buildPartial {
  ContentManifestSignature* returnMe = [[_builderResult retain] autorelease];
  self._builderResult = nil;
  return returnMe;
}
- (ContentManifestSignature_Builder*) mergeFrom:(ContentManifestSignature*) other {
  if (other == [ContentManifestSignature defaultInstance]) {
    return self;
  }
  if (other.hasSignature) {
    [self setSignature:other.signature];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ContentManifestSignature_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ContentManifestSignature_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setSignature:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasSignature {
  return _builderResult.hasSignature;
}
- (NSData*) signature {
  return _builderResult.signature;
}
- (ContentManifestSignature_Builder*) setSignature:(NSData*) value {
  _builderResult.hasSignature = YES;
  _builderResult.signature = value;
  return self;
}
- (ContentManifestSignature_Builder*) clearSignature {
  _builderResult.hasSignature = NO;
  _builderResult.signature = [NSData data];
  return self;
}
@end

